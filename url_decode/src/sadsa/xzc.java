package sadsa;

//import Base64;

//import it.sauronsoftware.base64.Base64;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.net.URLConnection;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.zip.InflaterInputStream;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;


import sun.misc.BASE64Decoder;

import org.json.*;

import org.apache.commons.codec.BinaryEncoder;
import org.apache.commons.codec.binary.Base32InputStream;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.binary.BaseNCodec;
//import org.apache.commons.codec.binary.Codec105ErrorInputStream;
import org.apache.commons.codec.binary.StringUtils;


public class xzc {
	
	
	public static String utf8_read(InputStream inputstream) throws IOException
	{
		String s;
		StringBuilder stringbuilder;
		s = null;
		stringbuilder = new StringBuilder();
		BufferedReader bufferedreader;
		String s1;
		bufferedreader = new BufferedReader(new InputStreamReader(inputstream, "UTF-8"));
		s1 = bufferedreader.readLine();
		String s2 = s1;
_L3:
		if (s2 == null) 
		{
		s = stringbuilder.toString();
		return s;
		}
		
		String s3;
		stringbuilder.append(s2);
		s3 = bufferedreader.readLine();
		s2 = s3;
		if (s2 == null) 
		{
		s = stringbuilder.toString();
		return s;
		}
		return s;
	}
	

	public static String i_b(byte abyte0[])
	{
		String s = null;
		try
		{
			byte abyte1[] = new byte[1 + abyte0.length];
			System.arraycopy(abyte0, 0, abyte1, 0, abyte0.length);
			abyte1[abyte0.length] = 0;
			InflaterInputStream inflaterinputstream = new InflaterInputStream(new ByteArrayInputStream(abyte1));
			ByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream(1024);
			do
			{
				int j = inflaterinputstream.read();
				if (j == -1)
				{
					bytearrayoutputstream.close();
					s = bytearrayoutputstream.toString();
					break;
				}
				bytearrayoutputstream.write(j);
			} while (true);
		}
		catch (Exception exception)
		{
			//com.anchorfree.log.a.a("Decompress", (new StringBuilder("unzipString failed, e: ")).append(exception.getMessage()).toString());
			exception.printStackTrace();
		}
		return s;
	}
	
	private static String ass(byte abyte0[], String s, boolean flag) throws NoSuchAlgorithmException,NoSuchPaddingException,InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, IOException
	{
			String s1;
			String s2;
			s1 = null;
		    s2="24a13c715d77bf40adcac666b79752e3".toUpperCase(); 		
			String sads1=StringUtils.newStringUsAscii(Base64.decodeBase64(abyte0));
	    	System.out.println(byte2hex(sads1.getBytes()));
	    	
			byte sad[]=sads1.getBytes();
			//System.out.println(sad);
					
		
			byte ivv[]="1234567890123456".getBytes("UTF-8");
		
	        System.out.print("IV length="+ivv.length);   
			IvParameterSpec ivparameterspec = new IvParameterSpec(ivv);
			
			byte sec[]=s2.getBytes("UTF-8");
			System.out.println(sec);
			
			
	        System.out.print("Key length="+s2.length());  
	            
	      
	        KeyGenerator _generator = KeyGenerator.getInstance( "AES" );  
	        SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG" ); 
	        secureRandom.setSeed(sec); 
	        _generator.init(128,secureRandom); 
	        _generator.init(128, new SecureRandom(sec));  
            SecretKey secretKey = _generator.generateKey();  
            byte[] enCodeFormat = secretKey.getEncoded(); 
            SecretKeySpec key = new SecretKeySpec(enCodeFormat, "AES"); 
            
		//	SecretKeySpec secretkeyspec = new SecretKeySpec(sec, "AES");
			Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");//算法/模式/补码方式 AES/CBC/NoPadding
			cipher.init(Cipher.DECRYPT_MODE, key, ivparameterspec);
			
	        System.out.print("abyte1 length="+abyte0.length);  
	        String sad_String=new String(abyte0);
	        System.out.println(byte2hex(abyte0));
	        
	        System.out.println("length:"+c(sad_String).getBytes().length);
			byte abyte2[] = cipher.doFinal(c(sad_String).getBytes());
			String s3 = null;
			if (abyte2 != null)
			{
				String sa3 = new String(abyte2);
				System.out.println(sa3);
				System.out.println(byte2hex(abyte2));
				if (flag)
					s3 = unzip(abyte2);//unzip
				else
					s3 = new String(abyte2);
			}


		s1 = s3;
		return s1;
	}

	public static String aaa(byte abyte0[], boolean flag) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, IOException
	{
		return  ass(abyte0,"ODIN11!#!G0LAKTE",flag);
	}
    public static String getFromBASE64(String s) { 
    	if (s == null) return null; 
    	BASE64Decoder decoder = new BASE64Decoder(); 
    	try { 
    	byte[] b = decoder.decodeBuffer(s); 
    	return new String(b); 
    	} catch (Exception e) { 
    	return null; 
    	} 
    	}
    
    
    private static String a(byte abyte0[], boolean flag) throws NoSuchAlgorithmException, UnsupportedEncodingException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
	{
		String s1;
		String s2;
		s1 = null;
		s2 ="24A13C715D77BF40ADCAC666B79752E3";
		String s3 = null;

			System.out.println("length:"+abyte0.length);
			SecureRandom.getInstance("SHA1PRNG").nextBytes(new byte[16]);
			byte abyte1[] = abyte0;//BASE64
			IvParameterSpec ivparameterspec = new IvParameterSpec("1234567890123456".getBytes("UTF-8"));//16
			SecretKeySpec secretkeyspec = new SecretKeySpec(s2.getBytes("UTF-8"), "AES");//16
			Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");
			cipher.init(2, secretkeyspec, ivparameterspec);
			byte abyte2[] = cipher.doFinal(abyte1);
			if (abyte2 != null)
			{
				if (flag)
					s3 = unzip(abyte2);//UZIP
				else
					s3 = new String(abyte2);
				
			}
		
		return s3;
	}
    public static String unzip(byte abyte0[])
   	{
      // 	System.out.println("start ZIP");
      // 	System.out.println("byte src:"+abyte0);
       	String dsa=new String(abyte0);
      // 	System.out.println("String src:"+dsa);
   		String s = null;
   		try
   		{
   			byte abyte1[] = new byte[1 + abyte0.length];
   			System.arraycopy(abyte0, 0, abyte1, 0, abyte0.length);
   			abyte1[abyte0.length] = 0;
   			InflaterInputStream inflaterinputstream = new InflaterInputStream(new ByteArrayInputStream(abyte1));
   			ByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream(1024);
   			do
   			{
   				int j = inflaterinputstream.read();
   				if (j == -1)
   				{
   					bytearrayoutputstream.close();
   					s = bytearrayoutputstream.toString();
   					break;
   				}
   				bytearrayoutputstream.write(j);
   			} while (true);
   		}
   		catch (Exception exception)
   		{
   			//com.anchorfree.log.a.a("Decompress", (new StringBuilder("unzipString failed, e: ")).append(exception.getMessage()).toString());
   			//exception.printStackTrace();
   		}
   	//	System.out.println("String dst:"+s);
   		return s;
   	}
    public static byte[] hex2byte(String strhex) {
        if (strhex == null) {
            return null;
        }
        int l = strhex.length();
        if (l % 2 == 1) {
            return null;
        }
        byte[] b = new byte[l / 2];
        for (int i = 0; i != l / 2; i++) {
            b[i] = (byte) Integer.parseInt(strhex.substring(i * 2, i * 2 + 2),16);
        }
        return b;
    }

    public static String byte2hex(byte[] b) {
        String hs = "";
        String stmp = "";
        for (int n = 0; n < b.length; n++) {
            stmp = (java.lang.Integer.toHexString(b[n] & 0XFF));
            if (stmp.length() == 1) {
                hs = hs + "0" + stmp;
            } else {
                hs = hs + stmp;
            }
        }
        return hs.toUpperCase();
    }
   
 
    public void testIsStringBase64() {
        String nullString = null;
        String emptyString = "";
        String validString = "abc===defg\n\r123456\r789\r\rABC\n\nDEF==GHI\r\nJKL==============";
        String invalidString = validString + ((char)0); // append null character
       
        Base64.isBase64(nullString); 
    }
    public static void testBase64(String aaa) {
        Base64 b64 = new Base64(BaseNCodec.MIME_CHUNK_SIZE, null);  // null lineSeparator same as saying no-chunking
        // bogus characters to decode (to skip actually) {e-acute*6}
        byte[] decode = b64.decode("SGVsbG{\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9}8gV29ybGQ=");
        String decodeString = StringUtils.newStringUtf8(decode);   
        System.out.println(decodeString);
        byte[] decode1 = b64.decode(aaa);
        String decodeString1 = StringUtils.newStringUtf8(decode1);  
        System.out.println(decodeString1);
        
    }
    private static String c(String s)
   	{
   		int j;
   		j = s.length() % 16;
   		if (j == 0)
   		{
   			return s;
   		}
   		else
   		{
   			int k;
   			int l;
   			k = 16 - j;
   			l = 0;
   			for (;l < k;l++) 
   			{
   			s = (new StringBuilder(String.valueOf(s))).append(' ').toString();
   			}
   			System.out.println("fun c :"+s.length());
   			return s;
   		}
   	}

    public static SecretKey getKey(String strKey) {
        try {         
           KeyGenerator _generator = KeyGenerator.getInstance( "AES" );
            SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG" );
           secureRandom.setSeed(strKey.getBytes("UTF-8"));
           _generator.init(128,secureRandom);
               return _generator.generateKey();
       }  catch (Exception e) {
            throw new RuntimeException( " 初始化密钥出现异常 " );
       }
     } 
    
    public static byte[] decodeUrlSafe(byte[] data) {
        byte[] encode = Arrays.copyOf(data, data.length);
        for (int i = 0; i < encode.length; i++) {
            if (encode[i] == '-') {
                encode[i] = '+';
            } else if (encode[i] == '_') {
                encode[i] = '/';
            }
        }
        return encode;
    }
    
    public static String Decrypt(String sSrc) throws Exception {
    	 
    	byte abyte0[];
		String s1,s2;
		abyte0 = null;
		s1 = "24a13c715d77bf40adcac666b79752e3".toUpperCase();//24a13c715d77bf40adcac666b79752e3 1C37DAF3782DB3BD8221B08811A09148
		s2 = "1234567890123456";
		//SecureRandom.getInstance("SHA1PRNG").nextBytes(new byte[16]);
		//byte abyte1[] = com.anchorfree.e.d.a(abyte0, abyte0.length);//BASE64
		byte[] sads1=Base64.decodeBase64(decodeUrlSafe(sSrc.getBytes()));
		
		/*
		IvParameterSpec ivparameterspec = new IvParameterSpec(s2.getBytes("UTF-8"));//16
		SecretKey secretkeyspec = getKey(s1);//16
		Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");
		cipher.init(2, secretkeyspec, ivparameterspec);
	    */
		SecureRandom.getInstance("SHA1PRNG").nextBytes(new byte[16]);
		IvParameterSpec ivparameterspec = new IvParameterSpec(s2.getBytes("UTF-8"));//16
		SecretKeySpec secretkeyspec = new SecretKeySpec(s1.getBytes("UTF-8"), "AES");//16
		Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");
		cipher.init(2, secretkeyspec, ivparameterspec);
		byte abyte2[] = cipher.doFinal(sads1);
		
		
		
		//System.out.println(sads1.getBytes("UTF-8").length);
		//String ss = (new StringBuilder(sads1)).append("\u0000\u0000").toString();  
		//System.out.println(sads1.length);
	//	System.out.println("CQ's result:"+byte2hex(sads1));
	//	byte abs[]=hex2byte("480AEC5539F19BE94C128BD6E490797AEDC6B8239A37606D2D84347A968123F48BAE72D9BD94C56DAD2D90343F692719346C39BA8845A7ADA8E522EE203F63DF71E2E36C90DDF3E70C3DFD0A52ACDEAC");
	//	String sadsa1=new String(Base64.encodeBase64URLSafe(abs)  );
	//	System.out.println("encodeBase64URLSafe:"+sadsa1);
	//	System.out.println("AD's result:"+byte2hex(abs));
		//System.out.println(sads1.length);
	
	//	byte abyte2[] = cipher.doFinal(sads1);//getbyte  有损失
		
		
	 //   System.out.println("CQ'S result:"+byte2hex(abyte2));
	 //   String sadsa="78DAAB562A28CA4FCBCC498DCFC94FCFCC53B2520AB60C30357754D2814B24E7A7A402C55DC302BC7C5CC3902452F27313C15A92724A53734B8B52528BF44A8B155080522D0047391E65000000000000";
	  //  System.out.println("AD'S result:"+byte2hex(hex2byte(sadsa)));
	  //  System.out.println("CQ'S result:"+unzip(abyte2));
	  //  System.out.println("AD'S result:"+unzip(hex2byte(sadsa)));
		return unzip(abyte2);
    }
    public static String decode_html_content(String content) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, IOException
    {
    	//String sads1=StringUtils.newStringUsAscii(Base64.decodeBase64(hex2byte(content)));
    	String sads1=new String(Base64.decodeBase64(hex2byte(content)));
    	System.out.println(byte2hex(sads1.getBytes()));
    	
    	return ass(sads1.getBytes(),"ODIN11!#!G0LAKTE",true);

    }

    private static String get_json_index(JSONObject jsonobject, String s) throws JSONException
	{
		String s1 = null;
		String s2 = jsonobject.getString(s);
		s1 = s2;
		return s1;

	}
	/*
	在使用AES进行加密解密之前，需要到Sun的官方网站上下载一个权限文件：jce_policy，
	目前它的下载网址是：http://www.oracle.com/technetwork/java/javase/downloads/index.html ,
	找到“Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files 6”后点击按钮下载，
	得到下载文件后解开，然后将其中的local_policy.jar和US_export_policy.jar
	拷贝到你的JAVA_HOME\jre\lib\security和JRE_HOME\lib\security两个目录下。
	如果没有这一步骤，进行加密解密的时候会产生java.security.InvalidKeyException异常
	*/
    public static void main(String[] args) throws Exception 
	 {
	 
    	if (args.length != 1) {
    	      System.err.println("需要URL输入");
    	      System.exit(-1);
    	    }
    	
//    	 URL yahoo = new URL("http://GIFT-STORE.US/qh5qlu5/a/profile/index.php?&u=IlobD-brz4RV8E47FVq9zQ&t=IlobD-brz4RV8E47FVq9zQ&e=VyGoycZsSulYE89tYkXlE8z1WC2YPnw09M2JjuwLifIf-Lwm8_LzpPQl7wSoPxId");
//        URL yahoo = new URL("http://bluemurder.us/no3zll6/a/sd/sd.php?u=IlobD-brz4RV8E47FVq9zQ&t=IlobD-brz4RV8E47FVq9zQ");
    	URL yahoo=new URL(args[0]);
    	URLConnection yc = yahoo.openConnection();
         BufferedReader in = new BufferedReader(
                                 new InputStreamReader(
                                 yc.getInputStream()));
         String inputLine;
         StringBuffer str=new StringBuffer();
         

         while ((inputLine = in.readLine()) != null) 
        	 str.append(inputLine);
         in.close();
         
         
         System.out.println("html get:"+str.toString());
         String input_=str.toString();
         
		//System.out.println("1c37daf3782db3bd8221b08811a09148".toUpperCase());
	    /*
         boolean aes_enable=true;
	    boolean zip_enable=true;
	    String sad="SArsVTnxm-lMEovW5JB5eu3GuCOaN2BtLYQ0epaBI_SLrnLZvZTFba0tkDQ_aScZNGw5uohFp62o5SLuID9j33Hi42yQ3fPnDD39ClKs3qw";
	    String sad1="480AEC5539F19BE94C128BD6E490797AEDC6B8239A37606D2D84347A968123F48BAE72D9BD94C56DAD2D90343F692719B2E0427AD2D049E8855F8C7270ECE21F32EB031B8FE0A814EAB341DE9447EED3";
	    String sad2="5341727356546E786D2D6C4D456F7657354A42356575334775434F614E3242744C59513065706142495F534C726E4C5A765A5446626130746B44515F6153635A4E477735756F68467036326F35534C754944396A33334869343279513366506E44443339436C4B73337177";
	    String sad3="cDoH9ZKIEcxVNMCDZ895hb-UZd_NH86ixEBz-D1OUzh4corq8pUOdCE3bHYI1ILupF161sAUl-izLdfC6G601UkBcYniVG6gvUANTVKLNdRm9-Y5VnSpLOZDL_0m6GnSsSxqMmyJfqOS83lA1zhr_G_Uo49nkkwBqcBAixv8TnIqC0lviWA5CjmbwS8y1sFDD0QaRmUHiFJA7gWYAMeUw7AsXKT6J0-vXCSxoIOx0blMBbndMWfDm-KhdhWuptlaQQXuhARjr5YgUUpq1W8kSiGX7nU7Q7o_7Yx6IJOixXgVns93XSr0qIpnJM1YZiXmFr2fuOvWywUL0ZUpuWD3h29tcwWYFrV-UCp6MONTd_P2gCxA10THjFwvOvkQMQ1tciJPVm7s8cpFPy4zVleRQztgVK6PtgJ6Am2UcPKZXTFK8NtP_2zatIrH43ClptPC9NKH8i24HJnIjnJFamZ4E5qjpjgANEvca6TaBK-GzFnNqY1PQhW6sTgDh5DgPlO7RNZ9c3jOR2BFtGeR2EHHViLGGeU2B0MlKqrK2yvx_gXx31IWAdLS7wvrNcXGujZ6X0z9bOKdEvIGl9DQHCs6TBe28gn1VXr-Su6FUarBfwCHS6jPcJKOXWJz_p4fsqbfPVrcvwCnIoatJ_YMnKgxjqDZ96051C3-6sJ2TgRPbZjzkLMsor-1WHAolD8P6BNSm8zdK-rzXvghjthWqRWswEoFzxgvDtUz-m1QO9WzlFM-9pRDoBxnCsV5eFcm5gnb1kHn0RPXCnD5Ote3_8CAv9-jNQkn8-ElK5GIMJAlU4-z0xr32szUGL4a4Jzu0Y5Xm-azdZbNmE66UfOgAqADwufDcF5hBtNiikv2EPGdjM0";
	    //System.out.println(unzip(hex2byte("496C6F62442D62727A34525638453437465671397A51")));
	    */
	   // System.out.println(Decrypt(input_));
	    String json_url=Decrypt(input_);
	    System.out.println(json_url);
	    /*
	    JSONArray url_list;
	    url_list = new JSONArray(json_url.trim());
	    JSONObject url_data_finally_;
	    url_data_finally_ = new JSONObject(json_url.trim());
	    System.out.println(get_json_index(url_data_finally_,"backup-list"));
	    */
	    JSONObject jsonObj = new JSONObject(json_url);
	    try{
		    JSONArray  jsonarr = jsonObj.getJSONArray("preferred-list");
		    for(int i=0;i<jsonarr.length();i++){
				System.out.println(jsonarr.getString(i));
			}
		    JSONArray  jsonarr1 = jsonObj.getJSONArray("elite-list");
		    for(int i=0;i<jsonarr1.length();i++){
				System.out.println(jsonarr1.getString(i));
			}
		    JSONArray  jsonarr2 = jsonObj.getJSONArray("backup-list");
		    for(int i=0;i<jsonarr2.length();i++){
				System.out.println(jsonarr2.getString(i));
			}
	    }
	    catch(Exception e)
	    {   	
	    	System.out.println("profile_login:"+jsonObj.getString("profile_login"));
	    	System.out.println("profile_code:"+jsonObj.getString("profile_code"));
	    	System.out.println("profile_domain:"+jsonObj.getString("profile_domain"));
	    }
	    
	    /*
	    String s = "{\"person\":{\"name\":\"张三\",\"age\":20}}";
		JSONObject jsonObj = new JSONObject(s);
		JSONObject  result = jsonObj.getJSONObject("person");
		System.out.println("姓名:"+result.getString("name")+" 年龄:"+result.getInt("age"));
		//解析object形式
		s="{\"persons\":[\"张三\",\"李四\",\"王五\"]}";
		jsonObj = new JSONObject(s);
		JSONArray jsonarr=jsonObj.getJSONArray("persons");
		for(int i=0;i<jsonarr.length();i++){
			System.out.println(jsonarr.getString(i));
		}
		*/
	    
	    
	   // System.out.println(Decrypt(sad3));
	    //System.out.println(decode_html_content(sad2));
	    /*
	    byte abyte0[]=sad.getBytes("utf-8");
	    System.out.println(byte2hex(abyte0));
	    System.out.println(abyte0);
	    String bbb=(new StringBuilder("jsonEncoded( ")).append(new String(abyte0)).append(", ").append(aes_enable).append(", ").append(zip_enable).append(" )").toString();
	    String bc=getFromBASE64(sad);
	    System.out.println(bc);
	    
	    byte[] sdsa=bc.getBytes("utf-8");
	    System.out.println("unzip input:"+sdsa);
	    String out1=unzip(sdsa);
	    System.out.println(out1);
	    
	    System.out.println("unzip:"+unzip(hex2byte("480A3F55393F3F3F4C123F3F3F3F797A3F3F3F233F37606D2D3F347A3F3F233F3F3F723F3F3F3F6D3F2D3F343F69271942253F2A3F213F3F743F3F3F493F051A3F3F7B31753F05393F3F3F3F003F3F3F")));
		
	      
	    System.out.println("own test");
	    String test1="CY0IkytQOdyek0dtxfKXG-oCHQZSv3qdFHepmzd_NiQH27BsdeCbszihiX5Os9SOa5NLMHCWj-9lEv1R1S8t9EnjPgs6kl400um5P-ofVCw855ZGGT1Tp_1OACD-xQIoVh4BBmRJpUgkphdix2NdmGrw4oA8RzXJ0bKeO0iShO4CC5e2s52JMqkZxjOTe_tXL-f-R6GUWcUTq-cdI6v-IDr-7knCMHE9DDvG2VCaXHmGLE0OmorLMK7Sd22Ik1NxQJ56eUftvzh-Lt3AWSPYS6n0E27AcNDLVgH_SUEvmsA";
	    String bc1=getFromBASE64(test1);
	    System.out.println(byte2hex(bc1.getBytes("utf-8")));
	    testBase64(test1);
	    String sads=StringUtils.newStringUsAscii(Base64.decodeBase64("VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg==".getBytes("UTF-8")));
	    System.out.println(sads);
	    String sads1=StringUtils.newStringUsAscii(Base64.decodeBase64(sad.getBytes("UTF-8")));
	    System.out.println(sads1);
	    System.out.println(byte2hex(sads1.getBytes()));
	    // System.out.println(byte2hex(Base64.decode(test1)));
	  //System.out.println(byte2hex(Base64.decode(test1.getBytes(), 1, test1.getBytes().length)));
	    
	    Base32InputStream in = new Base32InputStream(new Codec105ErrorInputStream(), true, 0, null);
	    if (abyte0 != null && abyte0.length > 0)
		{
			String s1;
			if (aes_enable)
			{
				//JSONObject_m2.d;
				s1 = aaa(abyte0, zip_enable);/////////////////important--------------->call to decode byte
				System.out.println("s1:"+s1);
			}
			//s1 = com.anchorfree.e.h.a(JSONObject_m2.d, abyte0, zip_enable);
			//JSONObject_m2.a(s1);
		}
	  */
	  }
}
